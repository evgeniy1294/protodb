# Protocol Debugger

Кроссплатформенное программное обеспечение, предназначенное в первую очередь для реверс-инжениринга протоколов проприетарных устройств. Protodb является свободным аналогом DockLight обладая более широким функционалом, в том числе поддержкой скриптов на LUA.

![Protocol Debugger GUI](documentation/content/images/seance.gif)

## Зависимости
* **Qt5/Qt6**;
* **Lua5 (5.4)** - реалиация стека Lua;
* **libzip** - архивы используются в механизме сессий;
* **nlohmann json** - современная библиотека для работы с json;

## Другие используемые библиотеки
* **Qt-Ads** - docking-система, на базе которой построен интерфейс программы. Будет загружена и собрана автоматически при сборке protodb;
* **Sol3 (sol2 v3.0)** - С++ header-only обёртка над Lua, предоставляющая пользователю широчайшие возможности по работе со стеком языка. Включена в проект;

## Знакомство с интерфейсом
Окно программы можно условно поделить на три части: боковая панель с гамбургер-меню(1), лог сеанса (2) и таблицы последовательностей(3).

<p align="center">
    <img src="documentation/content/images/mainwindow_label.png" width="512"/>
</p>

Приложение построено с использованием библиотеки Qt ADS, что позволяет пересобирать раскладку окна индивидуально под пользователя, а механизм сессий позволяет программе её запомнить. При необходимости, окно сессии или любую из таблиц можно закрыть, восстановить закрытые окна можно через гамбургер-меню <img src="documentation/content/images/list.svg" width="18">, раздел widgets.

![Protocol Debugger GUI](documentation/content/images/docking.gif)

### Сеанс
Вкладка содержит следующие элементы: заголовок с информацией о подключении (1), панель управления (2), лог(3) и строку быстрой отправки(4).
Панель управления содержит следующие элементы (слева-направо): кнопку "Очистить лог" <img class="icon" width="18px" height="18px" src="documentation/content/images/delete_cross.svg" />, поле "Фильтр", кнопку "Старт/Стоп" <img class="icon" width="24px" height="24px" src="documentation/content/images/run.svg" /> <img class="icon" width="24px" height="24px" src="documentation/content/images/stop_rect.svg" />, кнопку "Формат" (HEX/ASCII) <img class="icon" width="24px" height="24px" src="documentation/content/images/hex.svg" /><img class="icon" width="24px" height="24px" src="documentation/content/images/ascii.svg" />, кнопку "Автоматическая прокрутка" <img class="icon" width="24px" height="24px" src="documentation/content/images/sort_down.svg" /> и кнопку "Параметры сеанса" <img class="icon" width="18px" height="18px" src="documentation/content/images/settings_gear.svg" />.

<p align="center">
    <img src="documentation/content/images/seance.png" width="512"/>
</p>

Строка быстрой отправки предназначена для отправки данных без создания последовательностей. Функционал в данном случаю сокращен и позволяет только определять формат посылки между HEX и различными вариантами ASCII. Если сеанс не запущен, то при попытке отправки данных он будет запущен автоматически.

### Таблицы последовательностей
<p align="center">
    <img src="documentation/content/images/tables.png" width="512"/>
</p>

Таблицы хранят именованное описание последовательностей байт. Всего таблиц две: incoming (входящие) и outgoing (исходящие).

Таблица исходящих состоит из трёх столбцов: имя последовательности, интервал повтора и кнопка "Отправить/Прекратить отправку" <img width="24px" height="24px" src="documentation/content/images/arrow_enter.svg" /> <img width="24px" height="24px" src="documentation/content/images/stop_rect.svg" />. Эти последовательности можно отправить нажатием на соответствующую кнопку. Если значение интервала повтора равно нолю (no repeat), отправка будет однократной. В противном случае, повторные отправки будут происходить через заданный интервал.

Таблица входящих содержит список последовательностей, при приёме которых логика может отправить что-то в ответ. Таблица состоит из четырёх столбцов: имя последовательности, имя ответной последовательности(triggered), интервал задержки ответа и флаг "Использовать". Имя ответной последовательности должно соответствовать одной из последовательностей в таблице исходящих. Флаг "Использовать" позволяет включать/отключать реакцию на последовательности из таблицы.

Положение элементов таблицы можно сменить с помощью перетаскивания на нужную позицию.

Перед началом работы, последовательность необходимо создать. Для этого необходимо нажать на кнопкe <img width="18px" height="18px" src="documentation/content/images/add.svg" />, что создаст последовательность. Двойной клик по последовательности откроет диалог редактирования, удалить последовательность можно кнопкой с пиктограммой <img width="18px" height="18px" src="documentation/content/images/delete_minus.svg" />, а кнопка <img width="18px" height="18px" src="documentation/content/images/delete_cross.svg" /> очистит таблицу.

<p align="center">
    <img src="documentation/content/images/sequence_editor.gif" width="384"/>
</p>
В диалоге возможно переключаться между редактируемыми последовательностями, создать ещё одну последовательность, задать имя последовательности, а также написать для себя заметку об этой последовательности. Внимание! Некоторые настройки будут применены только после старта нового сеанса!

### Настройка сеанса
Сеанс имеет множество настроек, доступ к которым можно получить через кнопку "Параметры сеанса" <img width="18px" height="18px" src="documentation/content/images/settings_gear.svg" />. При нажатии на кнопку вам будет показан соответствующий диалог, в котором вы должны будете указать: тип устройства(1), путь до файла-скрипта(2) (опционально), настроить выбранное устойство(3), указать путь до текстового лога(4) (опционально) и, наконец, настроить сам механизм логгирования(5).

<p align="center">
    <img src="documentation/content/images/seance_config.png" width="384"/>
</p>

Настройки лога влияют не только на текстовый лог, но и на его отображение на вкладке "Сеанс". Ниже подробное доступных описание настроек: 

**Append file** - если включено, дописывать лог в конец файла, предварительно иначе затереть старые данные.

**Timestamp** - опция включает или выключает отображение метки времени в логе. Также возможно задать формат данной метки.

**Channel names** - опция включает или выключает текстовое отображение имени канала в логе.

**Channel 1, Channel 1, Comments** - всего существует четыре канала лога: first (RX), second (TX), user и error. Названия каналов RX, TX и USR можно менять для повышения читаемости, также можно отключить логгирование этих каналов.

На случай, если вы забыли указать путь до файла лога, его можно экспортировать или импортировать на вкладке "Сеанс" через гамбургер-меню <img width="18px" height="18px" src="documentation/content/images/list.svg" />.

Если вы не обнаружили необходимый тип устройства, проверьте, загружен ли соответствующий плагин.

### Делиметры
Делиметры предназначены для разделения пакетов данных между собой. На данный момент пользователю доступны два типа делиметров: по символу-разделителю и по времени.

<p align="center">
    <img src="documentation/content/images/delimeters.png" width="384"/>
</p>

Каждый раз, встречая разделитель, логика прогаммы будет формировать новое событие, которое будет зафиксировано в логе программы. Следовательно, данный символ можно использовать как для разделения идущих друг за другом пакетов данных, так и наоборот, для накопления данных - новое событие не будет зафиксировано, пока не будет получен разделитель. Последнее полезно при работе с низкоскоростными интерфейсами. Разделители могут иметь произвольные значения. Возможно указать два символа разделителя, например '\n\r' (CR LF), в этом случае новое событие будет сформировано по получении обоих символов подряд.

<p align="center">
    <img src="documentation/content/images/delimeter_example.png" width="256"/>
</p>

Бесконечное ожидание разделителя не всегда является хорошей идеей. Пользователю доступна возможность указать защитный интервал, по истечению которого будет сформировано событие, содержащее всё содержимое буфера. Таймер сбрасывается при получении каждого нового символа.

<p align="center">
    <img src="documentation/content/images/guard_timer.png" width="256"/>
</p>

### Калькулятор CRC
В программу встроен универсальный калькулятор контрольных сумм, использование которого возможно как из скриптов, так и через графический интерфейс, позволяющий выбрать готовую модель CRC для расчёта или задать свою.

<p align="center">
    <img src="documentation/content/images/crc_calculator.gif" width="384"/>
</p>

**Width** - cтепень порождающего контрольную сумму многочлена. Допустимые значения от 3 до 64.

**Poly** - cам пораждающий полином.

**Seed** - значение на момент начала вычислений.

**XOR** - число, с которым складывается по модулю 2 полученный результат.

**Reflect In** - флаг, указывающий на начало и направление вычислений, для обнаружения пакетов ошибок должно соответствовать порядку передачи в канале. Существует два варианта: False — начиная со старшего значащего бита (MSB-first) или True — с младшего (LSB-first);

**Reflect Out** - флаг, определяющий, инвертируется ли порядок битов регистра при входе на элемент XOR.


## Процесс сборки (Linux)
Начиная с версии 1.0.2 процесс сборки был значительно упрощён. Теперь достаточно следующей последовательности команд:
```sh
$ cmake ./ -B ./build -DQT_BUILD_VERSION:STRING=6 -DCMAKE_BUILD_TYPE=Release
$ cmake --build ./build --target all -- -j8
```

Где: 
_-DQT_BUILD_VERSION:STRING=6_ - сборка программы с Qt6.
_-DQT_BUILD_VERSION:STRING=5_ - сборка программы с Qt5.

Далее производим установку стандартными средствами cmake:
```sh
# cmake --install ./build --prefix "/usr/"
```
Внимание! Рекомендуется использовать готовые пакеты для пакетных менеджеров ваших дистрибутивов.

Следующие команды завершают процесс установки. Данные команды позволяют указать путь до библиотек protodb-base, protodb-gui и protodb-dev, которые необходимы для запуска и разработки плагинов для программы. Команды подразумевают, что библиотеки уже находятся в каталоге /usr/lib/protodb
```sh
$ mkdir -p /etc/ld.so.conf.d/
$ cd /etc/ld.so.conf.d/

$echo "/usr/lib/protodb" > ./protodb.conf
```

## Создание пакета (Archlinux)
Для пользователей Archlinux подготовлены PKGBUILD для пакетов protodb-qt5 и protodb-qt6. PKGBUILD производит автоматическую сборку и подготавливает пакет для пакетного менеджера дистрибутива. 

Сборка пакета:
```sh
$ makepkg -p pkgbuild-protodb-qt6
```
Результатом выполнения команды станет сжатый файл pkg, который необходимо установить в систему:
```sh
$ pacman -U protodb-qt6-1.0.2-1-x86_64.pkg.tar.zst
```

## Процесс сборки (Windows)
Процесс сборки для ОС Windows аналогичен, отличается только необходимостью предварительного создания сборочного окружения.
