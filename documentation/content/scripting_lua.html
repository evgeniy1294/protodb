<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>Manual</title>
    </head>
    <body style="font-size:16pt;font-family:helvetica">

        <p><center><h3>LUA-скрипты</h3></center></p>

        <p>
        LUA - это скриптовый язык программирования, особенностью является реализация большого числа программных сущностей минимумом синтаксических средств,
        а также простая интеграция в программное обеспечение, написанное на языке С/С++. Язык предназначен для пользователей,
        не являющихся профессиональными программистами, вследствие чего большое внимание уделено простоте дизайна
        и лёгкости обучения.
        </p>

        <p>
        На начальных этапах разработки protodb было решено не идти путём Docklight в виде разработки
        собственного DSL, а воспользоваться уже существующим скриптовым языком. LUA для этих целей подходил лучше всего.
        </p>

        <p>
        Логика программы в качестве реакции на события, а именно старт сессии, отправка данных, приём данных и завершение сессии,
        будет вызывать через стек LUA строго определенные функции. Ниже представлен базовый шаблон скрипта:
        </p>

        <p><pre>
function start()
    log:print("Seance started")
end

function stop()
    log:print("Seance stoped")
end

function beforeTransmit(msg)
    -- В обработчике beforeTransmit можно поработать с данными до их отправки.
    -- Например, добавить к посылке контрольные суммы.
    -- Помните, начальный индекс в массиве LUA - 1, а не 0.
end

function afterReceive(msg)
    -- Обработчик afterReceive служит для обработки принятых данных.
end
        </pre></p>

        <p>
        Также пользователю доступны некоторые стандартные библиотеки LUA, а именно base, bit32, math и string. Технически, добавление
        других библиотек не составляет труда, а текущий список ограничен по соображениям безопасности.
        </p>

        <p><center><h3>Служебные функции</h3></center></p>
        <p>
        <b>log:print(text)</b> - вывод текста в лог программы.
        </p>

        <p>
        <b>log:clear()</b> - очистка лога сессии. Не влияет на файловый лог.
        </p>

        <p>
        <b>session:stop()</b> - остановка сессии.
        </p>

        <p><center><h3>Вспомогательные функции</h3></center></p>
        <p>
        <b>utils:tableToFloat(bytes)</b> - возвращает float, собранный из массива длиной более 4-х байт (LE).
        </p>

        <p>
        <b>utils:tableToDouble(bytes)</b> - возвращает double, собранный из массива длиной более 8-ми байт (LE).
        </p>

        <p>
        <b>utils:tableToShort(bytes)</b> - возвращает uint16_t, собранный из массива длиной более 2-х байт (LE).
        </p>

        <p>
        <b>utils:tableToWord(bytes)</b> - возвращает uint32_t, собранный из массива длиной более 4-х байт (LE).
        </p>

        <p>
        <b>utils:tableToDword(bytes)</b> - возвращает uint64_t, собранный из массива длиной более 8-х байт (LE).
        </p>

        <p>
        <b>utils:floatToBytes(value)</b> - превращает float в массив из 4-х байт (LE).
        </p>

        <p>
        <b>utils:doubleToBytes(value)</b> - превращает double в массив из 8-ми байт (LE).
        </p>

        <p>
        <b>utils:shortToBytes(value)</b> - превращает uint16_t в массив из 2-х байт (LE).
        </p>

        <p>
        <b>utils:wordToBytes(value)</b> - превращает uint32_t в массив из 4-х байт (LE).
        </p>

        <p>
        <b>utils:dwordToBytes(value)</b> - превращает uint64_t в массив из 8-х байт (LE).
        </p>

        <p><center><h3>Расчет контрольных сумм</h3></center></p>
        <p>
        Класс CrcLogic содержит в себе реализацию логики расчета контрольных сумм.
        Реализация класса универсальна и позволяет задавать любые параметры модели CRC.
        Пример расчета контрольных сумм:
        </p>
        <p><pre>
local bt = { 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39 }
crc = CrcLogic:new()
    crc:setWidth(16)        -- Установка длина полинома в битах (от 3-х до 64-х).
    crc:setPoly(0x8005)     -- Значение полинома.
    crc:setSeed(0)          -- Начальное значение.
    crc:setReflectIn(true)  -- Начало и направление вычислений.
    crc:setReflectOut(true) -- Инверсия порядока битов регистра при входе на элемент XOR.
    crc:setXorOut(0)        -- Число, с которым складывается по модулю 2 полученный результат.
    crc:calculate(bt)       -- Расчет контрольных сумм. Может вызываться множество раз.

result = crc:finalize()     -- Получение результата(uint64_t) и сброс логики.
        </pre></p>

        <p><center><h3>Генерация последовательностей с помощью LUA</h3></center></p>

        <p>
        Плагин даёт вам возможность генерировать последовательности с помощью скрипта. Для понимания принципа работы
        представим lua-функцию, в которую в качестве аргумента передаётся пустой контейнер:
        </p>

        <p><pre>
function compile(bytes)
    -- Ваш код
end
        </pre></p>

        <p>
        Bytes - пустой массив, который вам нужно наполнить данными. Вы можете использовать все возможности языка, даже использовать
        функции:
        </p>

        <p><center>
            <img src="images/sequence_lua.png" />
        </center></p>

        <p>
        Пока неизвестно, насколько это удобно, но такая возможность пользователю дана.
        </p>

        <ul>
            <li><a href="scripting.html">Скрипты</a></li>
        </ul>
    </body>
</html>
